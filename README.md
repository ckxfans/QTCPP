# QTCPP
利用QT可视化编程实现停车场管理系统


停车场管理系统

用面向对象方法和面向对象程序设计语言，实现满足下述要求的停车场仿真程序。
1.问题域概述
某企业欲为其内部停车场建设一套信息系统，已经调查到的需求如下：
（1）企业为每位员工均发放一张感应式IC卡，卡上记录员工号。该卡由专门的卡管理系统 M 制作和维护，本系统需通过 M 来验证卡的有效性。
（2）在停车场的入口和出口处分别安装一个自动栏杆、一台感应式IC卡读卡器和一个车辆通过传感器，如下图所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190122203452344.png)
（3）入口处安装一个显示屏（上图中未给出），显示当前空闲车位数量。
若停车场当前没有空闲车位，则不允许汽车入场，只许场内的汽车出场。
（4）当一辆入场汽车到达入口时，用读卡器读出驾驶员的卡上信息，系统根据读出内容检查该卡的合法性：若该卡有效（需问M）&& 未被记录于当前场内卡号集合(即其车在场内的员工集合)中，即为合法卡。
a)若为合法卡，系统命令栏杆抬起；汽车通过入口后，入口传感器通知系统发出命令，栏杆放下，系统遂将该卡卡号记录于当前场内卡号集合中。
b)若为非法卡，则系统不发出栏杆抬起的命令，并发出告警信号。
（5）当一辆出场汽车到达出口时，用读入器读出驾驶员的卡上信息，系统根据读出内容检查该卡是否已经被记录在当前场内卡号集合中。
a)若已被记录，系统命令栏杆抬起；汽车通过出口后，出口传感器通知系统发出命令，栏杆放下，系统遂将该卡从当前场内卡号集合中删除。
b)若未被记录，系统不发出栏杆抬起的命令而发出告警信号，交由出口值班人员处理（见限定条件8）。

2.假设与限定条件
（1）该企业的员工总人数为E人，员工号为1~E。
（2）该停车场可容纳2*N辆汽车；入口到出口的距离=N+2个车位的宽度。
（3）汽车入场、出场时的读卡均需1秒钟，栏杆抬起、放下均需2秒钟，汽车的长度为2个车位宽度，汽车的行驶速度为每秒1个车位宽度。
（4）入场的汽车尾端通过入口传感器后，该传感器通知系统放下入口栏杆。
出场的汽车尾端通过出口传感器后，该传感器通知系统放下出口栏杆。
（5）汽车进入停车场后，总是选择离入口最近的一个空车位停车。
（6）汽车入场到达停车位后，需再用2秒从行车道停到车位上。
汽车出场时先用2秒从车位到达行车道，然后向出口行进。
（7）行车道上不允许汽车并行。
a)若有进场车与出场车争道冲突，让出场车先行；
b)若有出场车争道冲突，让离出口较远者先行；若与出口距离相同，随机决定让其中一辆车先行。
（8）出口值班人员处理不允许出场的汽车时，令该车返回原车位。若原车位已被占用，返回离出口最近的一个空车位。（很难）
（9）在整个仿真过程中不考虑驾驶员走入或走出停车场。
3.须仿真的活动
（1）程序开始时，停车场车位全空。此后随机产生要进场的汽车，并按上述描述进行入场仿真。
（2）汽车在停车场中的停留时间随机产生（为仿真的方便，可限定在5分钟之内，并在入场后立即设置）。到达停车时间后汽车即按上述描述进行出场仿真。
（3）定时报告（为方便，每分钟报告一次），应至少包括：当前时刻（包括时、分、秒）、当前场内车数、到目前为止的本次仿真“累计入场车数”、本次仿真“累计出场车数”、“本次仿真汽车的平均停车时间”。
（4）应将上条报告的每条信息均写入指定的运行记录文件。文件名格式为“仿真日期-仿真起始时间.TXT”。 其中<仿真日期>为yyyyMMdd格式，<仿真起始时间>为hhmmss格式。
（5）先按E=2*N进行上述仿真。达到预期目标后，再分别按E < 2*N和E > 2*N进行仿真。因此，要求E和N从命令行、或配置文件、或从界面上读入，不能写死在程序中。
（6）为检验系统的控制功能，应随机产生以下三类事件，并将这些事件的细节记录到上述的运行记录文件。
a)前文的两类争道冲突；
b)非本单位员工汽车要求入场的情况；
c)需按限定条件（8）处理的情况。

4.开发结果的行为特征
（1）仿真活动中，每隔1秒钟改变一次所有相关对象的状态。
（2）有简单的界面，以体现：
•当前的时间；从仿真开始到目前所经历的时长（以秒为单位）；
•当前空闲车位数（入口处的显示屏）；
•停车场内汽车停放的情况（简图即可，表示汽车时应同时显示对应员工的卡号，下同）；
•入场与出场汽车在场内的行进情况；（没实现）
•入口与出口自动栏杆的抬起与放下；
•拒绝入场和拒绝出场的情况；
•显示定时报告的数据。
注意能说明问题即可，切忌把主要精力放在界面上而忽视了实质问题。
5.提示
若没有学习过多进程或多线程实现技术，可能面临以下问题：既要计时，又要改变相关对象的状态，还要显示出当前所有对象的相关状态。
建议采用动画片的制作原理进行启发，即将多个固定和静止的画面定时、按顺序地放映出来，就变成了活动的画面。所以，可以在程序中定义一个主循环，在该循环之前进行必要的初始化，每1秒执行一次循环体，以遍历方式一一激励当前已经产生的对象，由它们根据自己的当前状态和相关的状态变化规则，决定是否需要改变、改变成什么样的状态，以及按照上述行为特征的设计展示必要的对象状态。这样，就可以用串行方式模拟并发的活动。
